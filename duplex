#include <avr/pgmspace.h>
const PROGMEM char forward[] =  {0x05, 0x10, 0x00, 0x00, 0x00, 0x01, 0x02, 0x00, 0x01, 0x55, 0x50};
const PROGMEM char backward[] = {0x05, 0x10, 0x00, 0x00, 0x00, 0x01, 0x02, 0x00, 0x02, 0x15, 0x51};
const PROGMEM char freq10[] =   {0x05, 0x10, 0x00, 0x01, 0x00, 0x01, 0x02, 0x03, 0xE8, 0x95, 0xFF};
const PROGMEM char freq15[] =   {0x05, 0x10, 0x00, 0x01, 0x00, 0x01, 0x02, 0x05, 0xDC, 0x97, 0x88};
const PROGMEM char stay[] =     {0x05, 0x10, 0x00, 0x00, 0x00, 0x01, 0x02, 0x00, 0x00, 0x94, 0x90};

const PROGMEM char test[] =     {0x05, 0x10, 0x00, 0x00, 0x00, 0x01, 0x02, 0x00, 0x00, 0x94, 0x90};

#include <SoftwareSerial.h>
SoftwareSerial SerialMaster(8, 9);
SoftwareSerial SerialSlave(10, 11);

int mEn = 7;
int sEn = 12;
int led = 13;

int k;
char output;
char input[15];

void setup() {
  pinMode(mEn, OUTPUT);
  pinMode(sEn, OUTPUT);
  pinMode(led, OUTPUT);
  digitalWrite(mEn, LOW);
  digitalWrite(sEn, LOW);
  digitalWrite(led, LOW);
  Serial.begin(9600);
  SerialMaster.begin(9600);
  SerialSlave.begin(9600);
  Serial.setTimeout(2);
}

void loop() {
  while (SerialSlave.available()) {
    SerialSlave.readBytes(input, 15);
    if (input[0] == test[0] && input[1] == test[1] && input[2] == test[2]) {
      Serial.print("if");
      sendMaster(freq15, 11);
      Serial.write(input, 3);
    }
    else {
      Serial.print("else");
      sendMaster(freq10, 11);
      Serial.write(input, 3);
    }
  }
}

void sendMaster (const char* h, int n){
  digitalWrite(mEn, HIGH);
  digitalWrite(led, HIGH);
  for (k = 0; k < n; k++) {
    output = pgm_read_word_near(h + k);
    Serial.print(output);
  }
  //delayMicroseconds (660);
  while (!(UCSR0A & (1 << UDRE0))) // Wait for empty transmit buffer
  UCSR0A |= 1 << TXC0; // mark transmission not complete
  while (!(UCSR0A & (1 << TXC0))); // Wait for the transmission to complete
  digitalWrite(mEn, LOW);
  digitalWrite(led, LOW);
}
